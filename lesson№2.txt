В этой части:

1. Валидаторы
2. Формы
3. Конфигурация Бандла


1. Как и со страницей “About” созданной в предыдущей главе, мы начнем с определения маршрута для страницы контактов.
    Откройте файл маршрутизации BloggerBlogBundle расположенный в src/Blogger/BlogBundle/Resources/config/routing.yml
    и добавьте следующее правило маршрутизации  src/Blogger/BlogBundle/Resources/config/routing.yml
    BloggerBlogBundle_contact
2. Давайте добавим функцию для страницы Контактов в контроллер Page нашего бандла BloggerBlog который находится
     в src/Blogger/BlogBundle/Controller/PageController.php - contactAction
3. Создайте шаблон - src/Blogger/BlogBundle/Resources/views/Page/contact.html.twig
4. Наконец, мы должны обновить ссылки в шаблоне приложения, чтобы добавить ссылку на страницу контактов
    app/Resources/views/base.html.twig - <li><a href="{{ path('BloggerBlogBundle_contact') }}">Contact</a></li>
5. Сущность Contact. Давайте начнём с создания класса, который представляет запрос от пользователя.
    Мы хотим, принять некоторую базовую информацию, такую как имя, тема и тело запроса.
     Создайте новый файл src/Blogger/BlogBundle/Entity/Enquiry.php и вставьте в следующее содержание:
6. Формы. EnquiryType .Создайте новый файл src/Blogger/BlogBundle/Form/EnquiryType.php и добавьте следующее содержание:
7. Класс EnquiryType представляет интерфейс FormBuilderInterface. Этот интерфейс используется классом FormBuilder.
    Класс FormBuilder это ваш лучший друг, когда дело доходит до создания форм. Он способен упростить процесс
    определения полей на основе метаданных. Поскольку наша сущность Enquiry очень простая мы не будет пока
     определять метаданные, так что FormBuilder будет выводить значения по умолчанию.
8. Создание формы в контроллере. Мы определили сущности Enquiry и EnquiryType, теперь мы можем обновить функцию contact,
    чтобы использовать их. Замените содержимое функции, расположенной
    src/Blogger/BlogBundle/Controller/PageController.php contactAction:
9. Мы начнём с создания экземпляра сущности Enquiry. Эта сущность представляет данные о contact запросе.
    Далее мы создадим форму. Определим EnquiryType, который мы создали ранее, и передадим нашему enquiry entity object.
10. Так как эти действия контроллера будут иметь дело с отображением и обработкой отправленной формы,
    мы должны проверить метод HTTP. Формы, как правило, передаются через метод POST, и наша форма не будет исключением.
     Если метод запроса будет POST, вызов submit($request)превратит отправленные данные обратно в элементы нашего
      $enquiry object. На данный момент объект $enquiry содержит представление о том, что отправил пользователь.
       Далее мы сделаем проверку, чтобы убедиться, что форма заполнена верно. Так как мы не указали ни одного валидатора
        на этот момент, форма всегда будет действительна. И наконец мы укажем шаблон для визуализации.
11. Мы должны импортировать пространства имен в наш контроллер т.к. используем новые классы. Обновите файл контроллера,
    расположенный в src/Blogger/BlogBundle/Controller/PageController.php
    Заявления должны быть размещены под уже имеющимися.
    // Import new namespaces
    use Symfony\Component\HttpFoundation\Request;
    use Blogger\BlogBundle\Entity\Enquiry;
    use Blogger\BlogBundle\Form\EnquiryType;
12. Благодаря шаблонизатору Twig вывод форм очень прост. Twig предоставляет многоуровневую систему для вывода форм,
    что позволяет выводить форму как одну целую сущность или в виде отдельных ошибок и элементов,
     в зависимости от уровня настройки которая вам требуется. Чтобы продемонстрировать мощь методов Twig
      выведем всю форму, следующим фрагментом кода - contact.html.twig
13. В то время как, это очень просто для создания прототипов и простых форм, это имеет и свои ограничения,
        когда необходимы расширенные настройки, что часто бывает с формами. Для нашей контактной формы, мы выберем
   золотую середину. Замените код шаблона, расположенный в src/Blogger/BlogBundle/Resources/views/Page/contact.html.twig
14. Первый метод form_start (вид, переменные) выводит тег начала формы. Этот помощник заботится о выводе метода
    конфигурации и action в форме. Он также будет включать в себя правильное значение ENCTYPE если
     форма содержит поля загрузки.
15. Второй метод form_errors будет выводить ошибки формы в том случае, если проверка не удалась.
16. Третий метод form_row выводит целые элементы, связанные с каждой областью формы. Это включает в себя какие-либо
    ошибки в поле, label поля и актуальный элемент поля.
17. Наконец мы используем метод form_rest. Это безопасный вариант, чтобы использовать метод в конце формы,
    чтобы сделать какие-либо поля которые вы возможно забыли, в том числе скрытые поля и Symfony2 Form CSRF token.
18. Давайте добавим некоторые стили, чтобы улучшить вид формы. Так как эти стили являются специфическими в пределах
     нашего бандла мы создадим стили в новом файле стилей внутри самого бандла. Создайте новый файл
      src/Blogger/BlogBundle/Resources/public/css/blog.css и вставьте стили.
19. Нам нужно, чтобы приложение знало, что мы хотим использовать эту таблицу стилей. Мы могли бы подключить
    таблицы стилей в шаблон страницы Контакты, но так как другие шаблоны будут также использовать эти стили позже,
     имеет смысл, импортировать стили в layout Blogger BlogBundle который мы создали в первой части.
     Откройте BloggerBlogBundle layout src/Blogger/BlogBundle/Resources/views/layout.html.twig и замените
      содержание следующим:
20. Вы можете видеть, что мы вывели блок стилей для его переопределения, который в свою очередь определен в родительском
    шаблоне. Важно заметить, что вызывается родительский метод. Это будет подключать файлы стилей,
    которые определены в app/Resources/base.html.twig, и позволяет добавить наш новый файл стилей. Мы не хотим,
     переопределять уже существующие таблицы стилей. Для того, чтобы функция asset правильно поключала файлы,
      нам нужно скопировать или связать ресурсы бандла в папке web нашего приложения. Это может быть
      сделано следующей командой в консоли:

    php app/console assets:install web --symlink

21. Теперь, если вы обновите страницу форма будет выглядеть намного привлекательнее.
22. Давайте изменим маршрут, расположенный src/Blogger/BlogBundle/Resources/config/routing.yml для обработки POST запросов.
23. Валидаторы. Давайте начнем с обновления сущности Enquiry, расположенной в src/Blogger/BlogBundle/Entity/Enquiry.php
        укажем несколько валидаторов. Убедитесь, что вы добавили 4 новых заявления в верхней части файла -
        src/Blogger/BlogBundle/Entity/Enquiry.php

        namespace Blogger\BlogBundle\Entity;

        use Symfony\Component\Validator\Mapping\ClassMetadata;
        use Symfony\Component\Validator\Constraints\NotBlank;
        use Symfony\Component\Validator\Constraints\Email;
        use Symfony\Component\Validator\Constraints\Length;
24. Чтобы определить валидаторы, мы должны реализовать статический метод loadValidatorMetadata. Он даст нам объект
    ClassMetadata. Мы можем использовать этот объект, чтобы установить ограничения на элементы наших сущностей.
    Первое заявление NotBlank применяется к элементу name. NotBlank валидатор проверяет не является ли поле пустым.
    Далее мы проверяем правильно ли пользователь ввёл свой e-mail. Служба Symfony2 предоставляет валидатор который
    проверяет правильность заполнения поля e-mail включая проверку домена.
    Мы хотим, чтобы поле темы не было пустым и содержало не более 50 символов, а сообщение не менее 50 символов.
    Вы можете применить столько валидаторов к одному полю сколько вам необходимо. Полный список валидаторов
     предоставляется в справочных документах Symfony2. Также можно создавать и пользовательские валидаторы.
25. Теперь, при отправке формы, ваши данные будут проходить валидацию. Попробуйте ввести неправильный адрес электронной
    почты. Вы должны увидеть сообщение об ошибке, информирующее о том, что адрес электронной почты
     является недействительным. Каждый валидатор выводит сообщение по умолчанию, которое может быть переопределено,
      если требуется. Например, чтобы изменить сообщения e-mail валидатора вы можете сделать следующее:
        $metadata->addPropertyConstraint('email', new Email(array(
            'message' => 'symblog does not like invalid emails. Give me a real one!'
        )));
26. Отправка Email. В то время как наша форма контактов позволяет пользователям отправлять запросы, ничего
    на самом деле пока не происходит. Давайте обновим контроллер, чтобы отправить письмо веб-мастеру блога.
    Symfony2 поставляется в комплекте с библиотекой SwiftMailer для отправки электронной почты.
    Swift Mailer является очень мощной библиотекой, мы только лишь прикоснёмся к тому, что эта библиотека может выполнять.
27. Конфигурация настроек SwiftMailer. Swift Mailer уже настроен из коробки работать в Symfony2, однако нам нужно
    настроить некоторые параметры, касающиеся способов отправки и полномочий. Откройте файл параметров,
    расположенный в app/config/parameters.yml и найдите настройки с префиксом mailer_.
    mailer_transport: smtp
    mailer_host: 127.0.0.1
    mailer_user: null
    mailer_password: null
28. Swift Mailer предоставляет ряд методов для отправки электронной почты, в том числе с использованием сервера SMTP,
    используя ‘местную' установку Sendmail, или даже с помощью учетной записи Gmail. Для простоты мы будем использовать
     учетную запись Gmail. Обновите параметры, подставив свой логин и пароль.
    mailer_transport: gmail
    mailer_encryption: ssl
    mailer_auth_mode: login
    mailer_host: smtp.gmail.com
    mailer_user: ваш_логин
    mailer_password: ваш_пароль
29. Контроллер.  Обновите Page контроллер расположенный src/Blogger/BlogBundle/Controller/PageController.php - contactAction
30. Когда вы используете библиотеку SwiftMailer чтобы создать Swift_Message, он может быть отправлен
    в виде электронной почты.
31. Так как библиотека Swift Mailer не использует пространства имен, мы должны поставить префикс перед классом
    Swift Mailer \. Это говорит PHP, вернуться обратно в глобальное пространство. Вам нужно будет добавить префикс всем
    классам и функциям, которые не имеют пространство имен с \. Если вы не разместите этот префикс перед классом
    Swift_Message PHP будет виден для класса в текущем пространстве имен, которое в этом примере является
     Blogger\BlogBundle\Controller, в результате чего будет выведена ошибка.
32. Мы также установили flash сообщение в сессии. Flash сообщения представляют собой сообщения, которые сохраняются
    в течение одного запроса. После этого они автоматически очищаются из Symfony2. Сообщение flash будет показано в
    шаблоне контакта, чтобы сообщить пользователю что запрос был отправлен. Так как flash сообщение сохраняется только
    в течение одного запроса, оно идеально подходит для уведомления пользователя об успехе предыдущих действий.
    Для отображения flash сообщения нам необходимо обновить шаблон контактов, расположенный
    src/Blogger/BlogBundle/Resources/views/Page/contact.html.twig.
33. Регистрация email’а веб-мастера. Symfony2 предоставляет систему конфигурации, которую мы можем использовать,
    чтобы определить наши собственные настройки. Мы будем использовать эту систему для установки электронной почты
    веб-мастера, а не жесткого кодирования адреса в контроллере выше. Таким образом, мы можем легко
    повторно использовать это значение в других местах без дублирования кода. Создайте новый файл
     src/Blogger/BlogBundle/Resources/config/config.yml и вставьте следующее:
34. При определении параметров хорошей практикой является разделение имен параметров на количество компонентов. Первая
    часть должна быть в нижнем регистре и использовать нижнее подчеркивание для разделения слов. В нашем примере мы
    превратили бандл BloggerBlogBundle в blogger_blog… Оставшаяся часть имени параметра может содержать любое количество
    частей разделенных. (Точкой). Это позволяет логически группировать параметры.
35. Для того, чтобы приложение Symfony2 использовало новые параметры, мы должны импортировать конфигурацию в главный
    файл конфигурации приложения, app/config/config.yml.
36. Тело нашего email, выводит шаблон. Создайте этот шаблон в
    src/Blogger/BlogBundle/Resources/views/Page/contactEmail.txt.twig
37. Вы будете удивлены, как вы можете проверить, что письма были отправлены. Symfony2 имеет решение для этого с помощью
    панели инструментов разработчика. Когда письмо будет отправлено значок-уведомление электронной почты появится в
    панели инструментов, который имеет всю информацию о письме. Если вы выполняете перенаправление после отправки
    электронной почты, как мы делаем для контактной формы, вам нужно будет установить intercept_redirects настройки
    app/config/config_dev.yml в значение true для того, чтобы увидеть уведомление электронной почты на панели инструментов.
38. Мы могли бы настроить SwiftMailer для отправки всех писем на определенный адрес электронной почты в среде Dev,
    поместив следующий параметр в конфигурационном файле Dev, расположенного app/config/config_dev.yml
    swiftmailer:
        delivery_address: development@symblog.dev